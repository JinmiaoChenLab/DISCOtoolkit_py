{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>  Deeply Integrated human Single-Cell Omics data </p> <p> \ud83d\udce6 1.1.4 \u2b50 Loading... \ud83c\udf74 Loading... \ud83d\udc40 Loading... \u2757 Loading... </p> <p></p> <p>DISCOtoolkit is an python package that allows users to access data and use the tools provided by the DISCO database. It provides the following functions:</p> <ul> <li>Filter and download DISCO data based on sample metadata and cell type information</li> <li>CELLiD: cell type annotation</li> <li>scEnrichment: geneset enrichment using DISCO DEGs</li> </ul> <p>Dependency Requirements:</p> <ul> <li>Numpy &gt;= 1.21.6</li> <li>Pandas &gt;= 1.4.2</li> <li>Scanpy &gt;= 1.9.3</li> <li>Scipy &gt;= 1.8.0</li> <li>joblib &gt;= 1.1.0</li> <li>pandarallel &gt;= 1.6.5</li> </ul>"},{"location":"#minimal-installation","title":"Minimal installation:","text":"<p>The DISCOtoolkit can be easily installed in the current Python environment using <code>pip</code>:</p> <pre><code>pip install discotoolkit\n</code></pre>"},{"location":"#installation-guide","title":"Installation guide:","text":"<p>we recommend to install miniconda first and install discotoolkit in virtual env</p> <p><pre><code>conda create --name disco python=3.8\n</code></pre> <pre><code>conda activate disco\n</code></pre> <pre><code>conda install ipykernel\n</code></pre> <pre><code>python -m ipykernel install --user --name disco --display-name \"disco\"\n</code></pre> <pre><code>python -m pip install discotoolkit\n</code></pre></p> <p>Note</p> <p>Please add -U parameter to pip to install the latest version. <code>pip install -U discotoolkit</code></p>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>Example in Jupyter notebook.</p> <p>Note</p> <p>Please select disco as the kernel for running the jupyter notebook</p>"},{"location":"#filter-and-download-disco-data","title":"Filter and download DISCO data","text":""},{"location":"#cell-type-annotation-using-cellid","title":"Cell Type Annotation using CELLiD","text":""},{"location":"#scenrichment","title":"scEnrichment","text":""},{"location":"#citation","title":"Citation","text":"<ol> <li>Li, Mengwei, et al. \"DISCO: a database of Deeply Integrated human Single-Cell Omics data.\" Nucleic acids research 50.D1 (2022): D596-D602.</li> </ol>"},{"location":"#follow-us-on-our-social-media","title":"Follow us on our social media!","text":"<p> HSCRM2</p> <p> JinmiaoChenLab Github repo</p>"},{"location":"API/","title":"API","text":"<p>DISCOtoolkit in python</p> <pre><code>import discotoolkit as dt\n</code></pre>"},{"location":"API/#download-data-api","title":"Download Data API","text":""},{"location":"API/#discotoolkitfilter","title":"discotoolkit.Filter","text":"dt.Filter(self, sample = None, project = None, tissue = None, disease = None, platform = None, sample_type = None, cell_type = None, cell_type_confidence = \"medium\", include_cell_type_children = True, min_cell_per_sample = 100) <p>Filter class object to save the attributes for filtering the dataset from DISCO</p> Parameters <code>sample</code> <code>String</code> Identifier of the sample (e.g., GSM3891625_3) <code>project</code> <code>String</code> Name of the project <code>tissue</code> <code>String</code> Type of tissue (e.g., Lung, Bladder) <code>disease</code> <code>String</code> Associated disease of the sample <code>platform</code> <code>String</code> Sequencing platform used (e.g., 10x3') <code>sample_type</code> <code>String</code> Type of the sample <code>cell_type</code> <code>String</code> Cell type of interest <code>cell_type_confidence</code> <code>String</code> Confidence level of the cell type prediction <code>include_cell_type_children</code> <code>Bool</code> Flag indicating whether to include subcell types <code>min_cell_per_sample</code> <code>Int</code> Minimum number of cells per sample Returns <code>Filter Class</code> Object representing the result of the function"},{"location":"API/#discotoolkitdownload_disco_data","title":"discotoolkit.download_disco_data","text":"dt.download_disco_data(metadata, output_dir = \"DISCOtmp\") <p>Function to download the data based on the given filter.</p> Parameters <code>metadata</code> <code>FilterData</code> FilterData class used to filter data from the DISCO database. <code>output_dir</code> <code>String</code> Directory for storing the downloaded data. Defaults to \"DISCOtmp\". Returns <code>None</code> This function does not return any object and instead downloads the data for the user."},{"location":"API/#cell-type-annotation-api","title":"Cell Type Annotation API","text":""},{"location":"API/#discotoolkitcellid_cluster","title":"discotoolkit.CELLiD_cluster","text":"dt.CELLiD_cluster(rna, ref_data=None, ref_deg=None, atlas=None, n_predict=1, ref_path=None, ncores=10) <p>Cell type annotation using reference data and computing the correlation between the user's cell gene expression and the reference data. The cell type with the highest correlation will be concluded as the cell type.</p> Parameters <code>rna</code> <code>Pandas DataFrame | Numpy array</code> User-defined dataframe. Needs to be transposed so that the index represents genes. <code>ref_data</code> <code>Pandas DataFrame</code> Reference dataframe used to compute the cell type annotation. Defaults to None. <code>ref_deg</code> <code>Pandas DataFrame</code> Reference DEG (Differentially Expressed Genes) database. Defaults to None. <code>atlas</code> <code>String</code> String of the atlas that the user wants to use as the reference. Defaults to None. <code>n_predict</code> <code>Integer</code> Number of predicted cell types. Defaults to 1. <code>ref_path</code> <code>String</code> Path string to the reference data. Defaults to None. <code>ncores</code> <code>Integer</code> Number of CPU cores used to run the data. Defaults to 10. Returns <code>Pandas DataFrame</code> Returns the Pandas DataFrame along with the correlation score."},{"location":"API/#scenrichment-api","title":"scEnrichment API","text":""},{"location":"API/#discotoolkitcellid_enrichment","title":"discotoolkit.CELLiD_enrichment","text":"dt.CELLiD_enrichment(input, reference=None, ref_path=None, ncores=10) <p>Function to generate enrichment analysis based on the reference gene sets following the DISCO pipeline.</p> Parameters <code>input</code> <code>Pandas DataFrame</code> User-defined DataFrame in the format of <code>(gene, fc)</code>. <code>gene</code> refers to the gene name, and <code>fc</code> refers to the log fold change. <code>reference</code> <code>Pandas DataFrame</code>, optional Reference datasets from DISCO. It is recommended to leave this as None, as the function will automatically retrieve the dataset from the server. Defaults to None. <code>ref_path</code> <code>String</code>, optional Path to the reference dataset or a file to read if it exists. Defaults to None. <code>ncores</code> <code>Integer</code>, optional Number of CPU cores to run the function. Defaults to 10. Returns <code>Pandas DataFrame</code> Returns the significant gene sets that are over-represented in a large set of genes."},{"location":"API/#visualisation-api","title":"Visualisation API","text":""},{"location":"API/#discotoolkitgene_search","title":"discotoolkit.gene_search","text":"dt.gene_search(gene, atlas = None, figsize = None, dpi = 300) <p>Function to search for the gene expression level the same as the input gene search bar in DISCO website.</p> Parameters <code>gene</code> <code>String</code> name of the gene in capital letter. e.g. LYVE1. <code>atlas</code> <code>String or List of String</code>, optional User defined atlas for visualisation. Default to None to search for all Atlases. <code>figsize</code> <code>tuple</code>, optional Size of the generated figure in tuple. Default to None. <code>dpi</code> <code>Integer</code>, optional DPI resolution for the figure. Default to 300. Returns <code>None</code> This function does not return anything beside plotting."},{"location":"CELLiD_celltype_annotation/","title":"Cell Type Annotation using CELLiD","text":"In\u00a0[64]: Copied! <pre># for google colab\n# pip install discotoolkit\n# import package\nimport os\nimport re\n\nimport discotoolkit as dt\nimport scanpy as sc\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# adding ignore warning to clean the code\nimport warnings\n\n# Ignore all warnings\nwarnings.filterwarnings('ignore')\n\n%load_ext autoreload\n%autoreload 2\n</pre> # for google colab # pip install discotoolkit # import package import os import re  import discotoolkit as dt import scanpy as sc import pandas as pd import numpy as np import matplotlib.pyplot as plt  # adding ignore warning to clean the code import warnings  # Ignore all warnings warnings.filterwarnings('ignore')  %load_ext autoreload %autoreload 2 <pre>The autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n</pre> In\u00a0[65]: Copied! <pre># setting params for the visualisation\n# verbosity: errors (0), warnings (1), info (2), hints (3)\nsc.settings.verbosity = 1\nsc.settings.set_figure_params(\n    dpi=300, frameon=False, figsize=(3, 3), facecolor='white')\n\n# Set the plotting backend to 'umap-learn' for interactive plot\nsc.settings.plotting_backend = 'umap-learn'\n</pre> # setting params for the visualisation # verbosity: errors (0), warnings (1), info (2), hints (3) sc.settings.verbosity = 1 sc.settings.set_figure_params(     dpi=300, frameon=False, figsize=(3, 3), facecolor='white')  # Set the plotting backend to 'umap-learn' for interactive plot sc.settings.plotting_backend = 'umap-learn' <p>To maintain simplicity, we exclusively employ sample metadata as the filtering criterion to extract a single sample from the <code>bone_marrow tissue</code> category. Subsequently, we proceed to download the pertinent data following the guidelines elucidated in the download data tutorial.</p> In\u00a0[66]: Copied! <pre># filter to only one sample\nfilter = dt.Filter(sample=\"AML003_3p\")\n\n# filter the database based on the metadata\nmetadata = dt.filter_disco_metadata(filter) \n\n# download the data and ignore if it is exist\ndt.download_disco_data(metadata)\n</pre> # filter to only one sample filter = dt.Filter(sample=\"AML003_3p\")  # filter the database based on the metadata metadata = dt.filter_disco_metadata(filter)   # download the data and ignore if it is exist dt.download_disco_data(metadata)  <pre>INFO:root:Retrieving metadata from DISCO database\nINFO:root:Filtering sample\nINFO:root:Retrieving cell type information of each sample from DISCO database\nINFO:root:1 samples and 6086 cells were found\nINFO:root: AML003_3p has been downloaded before. Ignore ...\n</pre> <p>We also provide a helper function that enables users to access and view the strings associated with the atlases</p> In\u00a0[67]: Copied! <pre># helper function to allow the user to see how many atlases are in disco database\nprint(dt.get_atlas())\n</pre> # helper function to allow the user to see how many atlases are in disco database print(dt.get_atlas()) <pre>['bone_marrow', 'breast_milk', 'blood', 'stomach', 'breast', 'placenta', 'adrenal_gland', 'pancreas', 'liver', 'eye', 'heart', 'skin', 'ovarian_cancer', 'testis', 'skeletal_muscle', 'ovary', 'tonsil', 'thymus', 'brain', 'bladder', 'gingiva', 'lung', 'adipose', 'PDAC', 'fibroblast', 'intestine', 'kidney']\n</pre> <p>The downloaded data is in h5ad format, and we need to import <code>scanpy</code> to read the data.</p> <p>Note</p> <p>     The input data for the cell type annotation function needs to be normalized and in non-log space. In the example below, the downloaded gene expression represents a count matrix, so we only need to normalize the data using `sc.pp.normalize_total`. If the data is in log space, please exponentiate it to convert it into non-log space.   </p> <p>The required format for the input data is (gene, cluster).</p> In\u00a0[68]: Copied! <pre># first we need to read the h5ad file and extract the raw gene expression\nadata = sc.read_h5ad(\"DISCOtmp/AML003_3p.h5ad\")\n\n# Rename columns with periods in `.obs` attribute\nfor col in adata.obs.columns:\n    new_col = re.sub(r'\\.', '_', col)\n    adata.obs.rename(columns={col: new_col}, inplace=True)\n\n# Rename columns with periods in `.var` attribute\nfor col in adata.var.columns:\n    new_col = re.sub(r'\\.', '_', col)\n    adata.var.rename(columns={col: new_col}, inplace=True)\n\n# apply normalise to the count data gene expression\n### Ignore this if the data has been normalised\n### please exponentiate if the data is in log-space\nsc.pp.normalize_total(adata, target_sum = 1e4)\nnorm_temp = adata.X\n\n# convert into dataframe for adding metadata\ntemp = pd.DataFrame(norm_temp.toarray(), columns=list(adata.var.index))\n\ntemp[\"cluster\"] = np.array(adata.obs[\"seurat_clusters\"]) # get the cluster metadata from \nintegrated_data = temp.groupby(\"cluster\").mean().transpose() # get the average expression for each cluster\n\n# # we want the rna format to have gene as index and cluster category as the columns\n# # here is the example. gene, cluster\nintegrated_data.head()\n</pre> # first we need to read the h5ad file and extract the raw gene expression adata = sc.read_h5ad(\"DISCOtmp/AML003_3p.h5ad\")  # Rename columns with periods in `.obs` attribute for col in adata.obs.columns:     new_col = re.sub(r'\\.', '_', col)     adata.obs.rename(columns={col: new_col}, inplace=True)  # Rename columns with periods in `.var` attribute for col in adata.var.columns:     new_col = re.sub(r'\\.', '_', col)     adata.var.rename(columns={col: new_col}, inplace=True)  # apply normalise to the count data gene expression ### Ignore this if the data has been normalised ### please exponentiate if the data is in log-space sc.pp.normalize_total(adata, target_sum = 1e4) norm_temp = adata.X  # convert into dataframe for adding metadata temp = pd.DataFrame(norm_temp.toarray(), columns=list(adata.var.index))  temp[\"cluster\"] = np.array(adata.obs[\"seurat_clusters\"]) # get the cluster metadata from  integrated_data = temp.groupby(\"cluster\").mean().transpose() # get the average expression for each cluster  # # we want the rna format to have gene as index and cluster category as the columns # # here is the example. gene, cluster integrated_data.head() Out[68]: cluster 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 MIR1302-2HG 0.000000 0.000000 0.000000 0.000000 0.00000 0.000000 0.000000 0.000000 0.00000 0.000000 0.000000 0.00000 0.0 0.000000 0.000000 0.000000 0.0 FAM138A 0.000000 0.000000 0.000000 0.000000 0.00000 0.000000 0.000000 0.000000 0.00000 0.000000 0.000000 0.00000 0.0 0.000000 0.000000 0.000000 0.0 OR4F5 0.000000 0.000000 0.000000 0.000000 0.00000 0.000000 0.000000 0.000000 0.00000 0.000000 0.000000 0.00000 0.0 0.000000 0.000000 0.000000 0.0 AL627309.1 0.019681 0.010808 0.006906 0.006409 0.00191 0.010536 0.002414 0.024108 0.00715 0.008123 0.003571 0.01634 0.0 0.027671 0.007016 0.037748 0.0 AL627309.3 0.000000 0.000000 0.002456 0.001417 0.00000 0.000000 0.009509 0.000000 0.00000 0.000000 0.000000 0.00000 0.0 0.000000 0.000000 0.000000 0.0 <p>Now that the data is ready, we can then apply the <code>dt.CELLiD_cluster</code> function. Specify the <code>n_predict</code> parameter to obtain predictions for <code>n</code> number of cell types.</p> In\u00a0[69]: Copied! <pre># apply cellid_cluster function to annotate the cluster\ncell_type = dt.CELLiD_cluster(rna = integrated_data, n_predict = 3)\n</pre> # apply cellid_cluster function to annotate the cluster cell_type = dt.CELLiD_cluster(rna = integrated_data, n_predict = 3) <pre>INFO: Pandarallel will run on 10 workers.\nINFO: Pandarallel will use Memory file system to transfer data between the main process and workers.\n</pre> <pre>[Parallel(n_jobs=10)]: Using backend LokyBackend with 10 concurrent workers.\n[Parallel(n_jobs=10)]: Done   7 out of  17 | elapsed:    5.0s remaining:    7.2s\n[Parallel(n_jobs=10)]: Done  17 out of  17 | elapsed:    7.2s finished\n</pre> In\u00a0[70]: Copied! <pre># the result is return as in Pandas DataFrame\ncell_type\n</pre> # the result is return as in Pandas DataFrame cell_type Out[70]: predicted_cell_type_1 predicted_cell_type_2 predicted_cell_type_3 source_atlas_1 source_atlas_2 source_atlas_3 score_1 score_2 score_3 input_index 0 MHCII low CD14 monocyte MHCII high CD14 monocyte Cycling S100A+ preNeutrophil bone_marrow bone_marrow bone_marrow 0.828 0.820 0.698 1 MHCII high CD14 monocyte MHCII low CD14 monocyte CD16 monocyte bone_marrow bone_marrow bone_marrow 0.818 0.754 0.744 2 MHCII high CD14 monocyte MHCII low CD14 monocyte Cycling S100A+ preNeutrophil bone_marrow bone_marrow bone_marrow 0.761 0.744 0.721 3 Common myeloid progenitor Granulocyte-monocyte progenitor Promyelocyte bone_marrow bone_marrow bone_marrow 0.681 0.665 0.665 4 Cycling S100A+ preNeutrophil cDC2 MHCII high CD14 monocyte bone_marrow bone_marrow bone_marrow 0.739 0.717 0.708 5 CD16 monocyte MHCII high CD14 monocyte MHCII low CD14 monocyte ovarian_cancer bone_marrow bone_marrow 0.831 0.821 0.772 6 pDC Myeloid pre-pDC cDC2 bone_marrow bone_marrow bone_marrow 0.701 0.675 0.652 7 cDC2 MHCII high CD14 monocyte Cycling S100A+ preNeutrophil bone_marrow bone_marrow bone_marrow 0.796 0.766 0.723 8 Myelocyte Cycling cDC2 S100A+ preNeutrophil bone_marrow bone_marrow bone_marrow 0.761 0.746 0.740 9 MHCII high CD14 monocyte MHCII low CD14 monocyte Cycling S100A+ preNeutrophil bone_marrow bone_marrow bone_marrow 0.796 0.780 0.740 10 MHCII high CD14 monocyte MHCII low CD14 monocyte cDC2 bone_marrow bone_marrow bone_marrow 0.793 0.751 0.722 11 MHCII high CD14 monocyte Cycling S100A+ preNeutrophil cDC2 bone_marrow bone_marrow bone_marrow 0.788 0.760 0.728 12 Naive B cell B cell B cell bone_marrow ovary ovarian_cancer 0.872 0.847 0.836 13 GZMB CD8 T cell CD16 NK cell INF-activated T cell ovarian_cancer ovarian_cancer bone_marrow 0.823 0.805 0.797 14 CD16 monocyte CD16 monocyte Monocyte ovarian_cancer bone_marrow ovary 0.840 0.817 0.716 15 Common lymphoid progenitor Common myeloid progenitor Granulocyte-monocyte progenitor bone_marrow bone_marrow bone_marrow 0.671 0.643 0.625 16 Mast cell Mast cell Megakaryocyte\u2013erythroid progenitor bone_marrow adipose bone_marrow 0.769 0.703 0.640 <p>From the DISCO website, we have prior knowledge that the downloaded sample is from bone marrow tissue. This information validates the accuracy of our cell type annotation function. Now, we can replace the cluster number with the predicted cell type.</p> In\u00a0[71]: Copied! <pre># since the seurat_clusters observation is in integer datatype, we first need to convert into string and make it as categorical\nadata.obs['seurat_clusters'] = adata.obs['seurat_clusters'].astype(str).astype(\"category\")\n\n# Generate the UMAP plot\nax = sc.pl.umap(adata, color='seurat_clusters', legend_loc='on data',\n           frameon=False, legend_fontsize=3.5, legend_fontoutline=1, show=False)\n\n# Set the plot title with the desired font size\nax.set_title('Seurat Clusters', fontsize=6)\n\n# Show the plot\nplt.show()\n</pre> # since the seurat_clusters observation is in integer datatype, we first need to convert into string and make it as categorical adata.obs['seurat_clusters'] = adata.obs['seurat_clusters'].astype(str).astype(\"category\")  # Generate the UMAP plot ax = sc.pl.umap(adata, color='seurat_clusters', legend_loc='on data',            frameon=False, legend_fontsize=3.5, legend_fontoutline=1, show=False)  # Set the plot title with the desired font size ax.set_title('Seurat Clusters', fontsize=6)  # Show the plot plt.show() <pre>... storing 'cell_type' as categorical\n</pre> <p>We can extract the relevant information from the cell_type dataframe and convert it into a dictionary. This dictionary will allow us to replace the cluster numbers in our data with their corresponding cell types.</p> In\u00a0[72]: Copied! <pre># we extract the information from cell_type dataframe and convert it into a dictionary for replacing the cluster number with cell type\npredicted_cell = cell_type[\"predicted_cell_type_1\"].copy()\npredicted_cell.index = predicted_cell.index.astype(str)\nmapping = predicted_cell.to_dict()\nadata.obs[\"predicted_cell\"] = adata.obs[\"seurat_clusters\"].replace(mapping)\n</pre> # we extract the information from cell_type dataframe and convert it into a dictionary for replacing the cluster number with cell type predicted_cell = cell_type[\"predicted_cell_type_1\"].copy() predicted_cell.index = predicted_cell.index.astype(str) mapping = predicted_cell.to_dict() adata.obs[\"predicted_cell\"] = adata.obs[\"seurat_clusters\"].replace(mapping) In\u00a0[73]: Copied! <pre># Generate plot with the legend location on the UMAP\n# Generate the UMAP plot\nax = sc.pl.umap(adata, color='predicted_cell', legend_loc='on data',\n           frameon=False, legend_fontsize=3.5, legend_fontoutline=1, show=False)\n\n# Set the plot title with the desired font size\nax.set_title('Predicted Cell Type', fontsize=6)\n\n# Show the plot\nplt.show()\n</pre> # Generate plot with the legend location on the UMAP # Generate the UMAP plot ax = sc.pl.umap(adata, color='predicted_cell', legend_loc='on data',            frameon=False, legend_fontsize=3.5, legend_fontoutline=1, show=False)  # Set the plot title with the desired font size ax.set_title('Predicted Cell Type', fontsize=6)  # Show the plot plt.show() In\u00a0[74]: Copied! <pre># Generate plot with the legend location on right side of the UMAP\n# Generate the UMAP plot\nax = sc.pl.umap(adata, color='predicted_cell', legend_loc='right margin',\n           frameon=False, legend_fontsize=3.5, show=False)\n\n# Set the plot title with the desired font size\nax.set_title('Predicted Cell Type', fontsize=6)\n\n# Adjust the legend font size\nhandles, labels = plt.gca().get_legend_handles_labels()\n\n# Adjust the size of the circles\nfor handle in handles:\n    handle.set_sizes([12])\n    handle.set_edgecolor('black')\n    handle.set_linewidth(0.5)\n\n# Move the legend to the right side of the plot\nplt.legend(handles=handles, labels=labels, prop={'size': 6},\n           loc='center left', bbox_to_anchor=(1.01, 0.5))\n\n# Show the plot\nplt.show()\n</pre> # Generate plot with the legend location on right side of the UMAP # Generate the UMAP plot ax = sc.pl.umap(adata, color='predicted_cell', legend_loc='right margin',            frameon=False, legend_fontsize=3.5, show=False)  # Set the plot title with the desired font size ax.set_title('Predicted Cell Type', fontsize=6)  # Adjust the legend font size handles, labels = plt.gca().get_legend_handles_labels()  # Adjust the size of the circles for handle in handles:     handle.set_sizes([12])     handle.set_edgecolor('black')     handle.set_linewidth(0.5)  # Move the legend to the right side of the plot plt.legend(handles=handles, labels=labels, prop={'size': 6},            loc='center left', bbox_to_anchor=(1.01, 0.5))  # Show the plot plt.show()"},{"location":"CELLiD_celltype_annotation/#cell-type-annotation-using-cellid","title":"Cell Type Annotation using CELLiD\u00b6","text":"<p>In this tutorial, we will provide a quick guideline for conducting cell type annotation using discotoolkit. The following steps outline the process:</p> <ol> <li>Visit the discotoolkit website to find a sample or cell type of interest.</li> <li>Utilize the <code>dt.filter_disco_metadata</code> function to filter the relevant data from the database.</li> <li>Employ the <code>dt.download_disco_data</code> function to download the data in the <code>h5ad</code> extension based on the filtered sample.</li> <li>Apply preprocessing to the counts matrix and obtain normalized gene expression, which will serve as the input for the <code>dt.CELLiD_cluster</code> function.</li> </ol>"},{"location":"Gene_search/","title":"Gene Search","text":"<p>We highly that users visit our DISCO website to access the web-based application for an enhanced and interactive gene search experience.</p> <p>In addition, researchers can utilize the <code>gene_search</code> function available in the <code>DISCOtoolkit</code> Python library. This function provides a convenient approach to visualize gene expression values for the gene of interest. By leveraging the capabilities of Python, it simplifies the data exploration process, offering users greater efficiency and flexibility.</p> <p>By utilizing both the web-based application and the <code>gene_search</code> function, users can gain valuable insights into gene expression profiles and analyze their data using complementary approaches. Researchers are encouraged to select the method that aligns best with their preferences and research requirements.</p> In\u00a0[9]: Copied! <pre># for google colab\n# pip install discotoolkit\n# first import the installed package\nimport discotoolkit as dt\n\n# adding ignore warning to clean the code\nimport warnings\n\n# Ignore all warnings\nwarnings.filterwarnings('ignore')\n</pre> # for google colab # pip install discotoolkit # first import the installed package import discotoolkit as dt  # adding ignore warning to clean the code import warnings  # Ignore all warnings warnings.filterwarnings('ignore') <p>Optional</p> <p>     The `atlas` argument is optional for the `gene_search` function   </p> In\u00a0[10]: Copied! <pre># get all the altas from disco in case the user want to check only for selected atlas.\nall_atlas = dt.get_atlas()\n</pre> # get all the altas from disco in case the user want to check only for selected atlas. all_atlas = dt.get_atlas() <p>The <code>gene_search</code> function only requires one argument: the gene name. For example, to search for the \"LYVE1\" gene, use the following syntax:</p> In\u00a0[11]: Copied! <pre>dt.gene_search(\"LYVE1\")\n</pre> dt.gene_search(\"LYVE1\") <p>To search for specific atlas, the input for <code>atlas</code> argument can either be a string or list of string as follow:</p> In\u00a0[12]: Copied! <pre># string only\ndt.gene_search(\"LYVE1\", atlas=\"intestine\")\n</pre> # string only dt.gene_search(\"LYVE1\", atlas=\"intestine\") In\u00a0[13]: Copied! <pre># list of string\ndt.gene_search(\"LYVE1\", atlas=[\"lung\", \"intestine\"])\n</pre> # list of string dt.gene_search(\"LYVE1\", atlas=[\"lung\", \"intestine\"]) <p>Other optional arguments: <code>figsize</code> and <code>dpi</code>, are mainly use for adjusting the figure for ease of use.</p> <p>For example:</p> In\u00a0[14]: Copied! <pre># changing from 300 to 100 dpi\ndt.gene_search(\"LYVE1\", atlas=\"intestine\", dpi = 100)\n</pre> # changing from 300 to 100 dpi dt.gene_search(\"LYVE1\", atlas=\"intestine\", dpi = 100) In\u00a0[15]: Copied! <pre># changing from 300 to 100 dpi and adjusting the figure\ndt.gene_search(\"LYVE1\", atlas=\"intestine\", figsize= (2, 9), dpi = 100)\n</pre> # changing from 300 to 100 dpi and adjusting the figure dt.gene_search(\"LYVE1\", atlas=\"intestine\", figsize= (2, 9), dpi = 100)"},{"location":"Gene_search/#gene-search","title":"Gene Search\u00b6","text":""},{"location":"download_data/","title":"Download Data","text":"<p>We recommend the user visit our DISCO website and filter the sample based on the metadata provided on the website.</p> <p>In this tutorial, we will provide a quick guideline for downloading the data using discotoolkit. Steps:</p> <ul> <li>Visit the website to find a sample or cell type of interest.</li> <li>Utilize the <code>dt.filter_disco_metadata</code> function to filter the data from the database.</li> <li>Employ the <code>dt.download_disco_data</code> function to download the data in the <code>h5ad</code> extension based on the filtered sample.</li> </ul> In\u00a0[1]: Copied! <pre># for google colab\n# pip install discotoolkit\n# first import the installed package\nimport discotoolkit as dt\nimport os\nimport scanpy as sc\nimport anndata as ad\nimport re\nimport matplotlib.pyplot as plt\n\n# adding ignore warning to clean the code\nimport warnings\n\n# Ignore all warnings\nwarnings.filterwarnings('ignore')\n</pre> # for google colab # pip install discotoolkit # first import the installed package import discotoolkit as dt import os import scanpy as sc import anndata as ad import re import matplotlib.pyplot as plt  # adding ignore warning to clean the code import warnings  # Ignore all warnings warnings.filterwarnings('ignore') In\u00a0[2]: Copied! <pre># setting params for the visualisation\n# verbosity: errors (0), warnings (1), info (2), hints (3)\nsc.settings.verbosity = 1\nsc.settings.set_figure_params(\n    dpi=300, frameon=False, figsize=(3, 3), facecolor='white')\n\n# Set the plotting backend to 'umap-learn' for interactive plot\nsc.settings.plotting_backend = 'umap-learn'\n</pre> # setting params for the visualisation # verbosity: errors (0), warnings (1), info (2), hints (3) sc.settings.verbosity = 1 sc.settings.set_figure_params(     dpi=300, frameon=False, figsize=(3, 3), facecolor='white')  # Set the plotting backend to 'umap-learn' for interactive plot sc.settings.plotting_backend = 'umap-learn' <p>For this example, we wanted to download LYVE1 macrophage from lung tissue as our cell type of interest. We subset only the highly confident cell type prediction based on our manual annotation and the minimum 300 cells per sample. Notice that we specify <code>include_cell_type_children</code> as true to include all sub-cell types if applicable.</p> In\u00a0[3]: Copied! <pre># filtering the sample based on the metadata\nfilter = dt.Filter(\n    sample = None,\n    project = None,\n    tissue = \"lung\",\n    platform = [\"10x3'\", \"10x5'\"],\n    sample_type = [\"Normal\", \"Adjacent normal\"],\n    cell_type = \"LYVE1 macrophage\",\n    cell_type_confidence = \"high\",\n    include_cell_type_children = True,\n    min_cell_per_sample = 300\n)\n</pre> # filtering the sample based on the metadata filter = dt.Filter(     sample = None,     project = None,     tissue = \"lung\",     platform = [\"10x3'\", \"10x5'\"],     sample_type = [\"Normal\", \"Adjacent normal\"],     cell_type = \"LYVE1 macrophage\",     cell_type_confidence = \"high\",     include_cell_type_children = True,     min_cell_per_sample = 300 ) In\u00a0[4]: Copied! <pre># apply the filter of interest\nmetadata = dt.filter_disco_metadata(filter)\n</pre> # apply the filter of interest metadata = dt.filter_disco_metadata(filter) <pre>INFO:root:Retrieving metadata from DISCO database\nINFO:root:Filtering sample\nINFO:root:Retrieving cell type information of each sample from DISCO database\nINFO:root:Retrieving ontology from DISCO database\nINFO:root:8 samples and 3863 cells were found\n</pre> <p>After applying the filter to the database, now we can download the dataset into the <code>disco_data</code> directory.</p> In\u00a0[5]: Copied! <pre># download data to the local directory\ndir_path = \"disco_data\"\ndownload_log = dt.download_disco_data(metadata, output_dir = dir_path)\n</pre> # download data to the local directory dir_path = \"disco_data\" download_log = dt.download_disco_data(metadata, output_dir = dir_path) <pre>INFO:root:Downloading data of GSM3891625_3\nINFO:root:Downloading data of GSM5068934_9\nINFO:root:Downloading data of GSM5068933_11\nINFO:root:Downloading data of GSM5068932_8\nINFO:root:Downloading data of GSM5068924_9\nINFO:root:Downloading data of GSM5068929_11\nINFO:root:Downloading data of GSM5068929_16\nINFO:root:Downloading data of GSM5068936_4\nINFO:root:Downloading data of GSM5068928_12\n</pre> <p>We can check to see if the files have been download successfully using <code>os</code> library with function <code>listdir()</code></p> In\u00a0[6]: Copied! <pre># double checking to see if the files have been download successf\nos.listdir(dir_path)\n</pre> # double checking to see if the files have been download successf os.listdir(dir_path) Out[6]: <pre>['GSM5068933_11.h5ad',\n 'GSM3891625_3.h5ad',\n 'GSM5068934_9.h5ad',\n 'GSM5068929_16.h5ad',\n 'GSM5068932_8.h5ad',\n 'GSM5068928_12.h5ad',\n 'GSM5068936_4.h5ad',\n 'GSM5068924_9.h5ad',\n 'GSM5068929_11.h5ad']</pre> <p>Since the data has been successfully downloaded, we can then use the <code>scanpy</code> library to visualize the UMAP of the downloaded data. This can be achieved by concatenating the files in the downloaded directory into one combined <code>anndata</code>. The combined <code>anndata</code> is useful for downstream analysis or integration, enabling further study of the scRNA-seq.</p> In\u00a0[7]: Copied! <pre>directory = 'disco_data'\nadata_list = []\n\n# Read and store datasets\nfor filename in os.listdir(directory):\n    if filename.endswith('.h5ad'):\n        filepath = os.path.join(directory, filename)\n        adata = sc.read(filepath)\n\n        # Rename columns with periods in `.obs` attribute\n        for col in adata.obs.columns:\n            new_col = re.sub(r'\\.', '_', col)\n            adata.obs.rename(columns={col: new_col}, inplace=True)\n\n        # Rename columns with periods in `.var` attribute\n        for col in adata.var.columns:\n            new_col = re.sub(r'\\.', '_', col)\n            adata.var.rename(columns={col: new_col}, inplace=True)\n\n        del adata.raw\n\n        adata_list.append(adata)\n        \n# Concatenate the datasets\ncombined_adata = ad.concat(adata_list)\n\n# making the obs name unique\ncombined_adata.obs_names_make_unique()\n\n# Print the concatenated dataset\nprint(combined_adata)\n</pre> directory = 'disco_data' adata_list = []  # Read and store datasets for filename in os.listdir(directory):     if filename.endswith('.h5ad'):         filepath = os.path.join(directory, filename)         adata = sc.read(filepath)          # Rename columns with periods in `.obs` attribute         for col in adata.obs.columns:             new_col = re.sub(r'\\.', '_', col)             adata.obs.rename(columns={col: new_col}, inplace=True)          # Rename columns with periods in `.var` attribute         for col in adata.var.columns:             new_col = re.sub(r'\\.', '_', col)             adata.var.rename(columns={col: new_col}, inplace=True)          del adata.raw          adata_list.append(adata)          # Concatenate the datasets combined_adata = ad.concat(adata_list)  # making the obs name unique combined_adata.obs_names_make_unique()  # Print the concatenated dataset print(combined_adata) <pre>AnnData object with n_obs \u00d7 n_vars = 3863 \u00d7 33538\n    obs: 'orig_ident', 'nCount_RNA', 'nFeature_RNA', 'percent_mt', 'RNA_snn_res_0_8', 'seurat_clusters', 'cell_type', 'cell_type_score', 'sampling_weight'\n    obsm: 'X_pca', 'X_umap'\n</pre> In\u00a0[8]: Copied! <pre># Generate the UMAP plot\nax = sc.pl.umap(combined_adata, color='cell_type', legend_loc='on data',\n           frameon=False, legend_fontsize=3.5, legend_fontoutline=1, show=False)\n\n# Set the plot title with the desired font size\nax.set_title('Cell Type', fontsize=6)\n\n# Show the plot\nplt.show()\n</pre> # Generate the UMAP plot ax = sc.pl.umap(combined_adata, color='cell_type', legend_loc='on data',            frameon=False, legend_fontsize=3.5, legend_fontoutline=1, show=False)  # Set the plot title with the desired font size ax.set_title('Cell Type', fontsize=6)  # Show the plot plt.show() <pre>... storing 'cell_type' as categorical\n</pre> <p>Great! We have successfully filtered and downloaded the cell type-specific data from the DISCO database.</p>"},{"location":"download_data/#download-data","title":"Download Data\u00b6","text":""},{"location":"scEnrichment/","title":"scEnrichment","text":"In\u00a0[9]: Copied! <pre># for google colab\n# pip install discotoolkit\n# import package\n\nimport discotoolkit as dt\nimport scanpy as sc\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# adding ignore warning to clean the code\nimport warnings\n\n# Ignore all warnings\nwarnings.filterwarnings('ignore')\n\n%load_ext autoreload\n%autoreload 2\n\nsns.set_theme(rc={'figure.dpi': 300})\n</pre> # for google colab # pip install discotoolkit # import package  import discotoolkit as dt import scanpy as sc import pandas as pd import matplotlib.pyplot as plt import seaborn as sns  # adding ignore warning to clean the code import warnings  # Ignore all warnings warnings.filterwarnings('ignore')  %load_ext autoreload %autoreload 2  sns.set_theme(rc={'figure.dpi': 300}) <pre>The autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n</pre> <p>The user can input either a gene list or a gene list with log fold change as the input to the <code>dt.CELLiD_enrichment</code> function.</p> <p>Example of the DEGs:</p> In\u00a0[10]: Copied! <pre># testing DEG from DEGs of acinar cell(Peng, Junya et al.)\n# Reference is in DISCO website\n\ntest_genes = {\"gene\":[\"PRSS1\", \"CTRB2\", \"CELA3A\", \"CTRB1\", \"REG1B\", \"CLPS\", \"CPB1\", \"CPA1\", \"PLA2G1B\", \"REG3A\", \"CTRC\"],\n            #   \"fc\":[5.236605052, 5.179753462, 4.724315075, 4.702706704, 4.65145949, 4.513887613, 4.351968886, 4.311988687, 4.272185339, 4.253882194, 4.208933992]\n              }\n\ndeg_df = pd.DataFrame(test_genes)\n\ndeg_df.head()\n</pre> # testing DEG from DEGs of acinar cell(Peng, Junya et al.) # Reference is in DISCO website  test_genes = {\"gene\":[\"PRSS1\", \"CTRB2\", \"CELA3A\", \"CTRB1\", \"REG1B\", \"CLPS\", \"CPB1\", \"CPA1\", \"PLA2G1B\", \"REG3A\", \"CTRC\"],             #   \"fc\":[5.236605052, 5.179753462, 4.724315075, 4.702706704, 4.65145949, 4.513887613, 4.351968886, 4.311988687, 4.272185339, 4.253882194, 4.208933992]               }  deg_df = pd.DataFrame(test_genes)  deg_df.head() Out[10]: gene 0 PRSS1 1 CTRB2 2 CELA3A 3 CTRB1 4 REG1B <p>Now that we have our data ready, we can proceed to run the function.</p> In\u00a0[11]: Copied! <pre># get enrichment analysis result using dt.CELLiD_enrichment\nresults = dt.CELLiD_enrichment(deg_df)\n</pre> # get enrichment analysis result using dt.CELLiD_enrichment results = dt.CELLiD_enrichment(deg_df) <pre>INFO:root:Comparing the ranked gene list to reference gene sets...\n[Parallel(n_jobs=1)]: Using backend SequentialBackend with 1 concurrent workers.\n[Parallel(n_jobs=1)]: Done 3999 out of 3999 | elapsed:   48.7s finished\n</pre> In\u00a0[12]: Copied! <pre># get the top 10 results\nresults.head(10)\n</pre> # get the top 10 results results.head(10) Out[12]: pval or name gene background overlap geneset 32 0.0 842.815 Acinar cell vs All others in pancreas CTRC,CELA3A,REG1B,REG3A,CPB1,CLPS,CPA1,PRSS1,P... 5783 11 91 42 0.0 743.688 Acinar cell vs Ductal/EC doublet like cell in ... CTRB2,PRSS1,CPB1,CPA1,CTRC,CTRB1,CELA3A,PLA2G1... 9711 11 164 22 0.0 569.849 Acinar cell vs TUBA1A+ ductal cell in pancreas CTRB2,CTRB1,CELA3A,PRSS1,PLA2G1B,CTRC,CPB1,CPA... 5783 11 129 82 0.0 531.813 Acinar cell vs HSP+ pancreatic ductal cell in ... CTRC,CTRB2,CTRB1,CELA3A,CPB1,PRSS1,CPA1,CLPS,P... 9711 11 224 40 0.0 519.397 Acinar cell vs Pancreatic ductal cell in PDAC PRSS1,CTRB1,CTRC,CELA3A,CTRB2,CPB1,CPA1,CLPS,P... 9711 11 229 41 0.0 507.536 Acinar cell vs CCL2+ pancreatic ductal cell in... PRSS1,CELA3A,CTRC,CTRB1,CPB1,CPA1,CTRB2,CLPS,P... 9711 11 234 54 0.0 505.227 Acinar cell vs All others in PDAC CTRC,CELA3A,CPB1,CLPS,CPA1,PRSS1,PLA2G1B,CTRB2... 9711 11 235 81 0.0 293.242 KLRB1 CD8 T cell vs XCL1 NK cell in PDAC CLPS,PRSS1,CTRB1,CPA1,CELA3A,CTRC,CPB1,CTRB2,P... 9711 9 117 8 0.0 227.122 Paneth cell vs Goblet cell in intestine REG3A,REG1B 11184 2 50 77 0.0 189.087 KLRB1 CD8 T cell vs CXCL13 exhausted CD8 T cel... CPA1,CLPS,CTRB1,CPB1,CTRC,CTRB2,PRSS1,CELA3A,P... 9711 9 176 <p>We can visualize the results using a horizontal barplot with the help of the <code>seaborn</code> library.</p> In\u00a0[13]: Copied! <pre># setting the theme to whitegrid\nsns.set_theme(style=\"whitegrid\")\n\n# Initialize the matplotlib figure\nf, ax = plt.subplots(figsize=(6, 15))\n\n# plot only the top 20 results\nsns.barplot(x=\"or\", y=\"name\", data=results.head(20), color=\"b\")\n\n# adding axis title\nax.set(ylabel=\"Gene sets\",\n       xlabel=\"Odds Ratio\")\n\n# make the plot look cleaner and nicer\nsns.despine(left=True, bottom=True)\n</pre> # setting the theme to whitegrid sns.set_theme(style=\"whitegrid\")  # Initialize the matplotlib figure f, ax = plt.subplots(figsize=(6, 15))  # plot only the top 20 results sns.barplot(x=\"or\", y=\"name\", data=results.head(20), color=\"b\")  # adding axis title ax.set(ylabel=\"Gene sets\",        xlabel=\"Odds Ratio\")  # make the plot look cleaner and nicer sns.despine(left=True, bottom=True)"},{"location":"scEnrichment/#scenrichment","title":"scEnrichment\u00b6","text":"<p>In this tutorial, we will provide a quick guideline for applying the scEnrichment feature of discotoolkit on DEGs (Differentially Expressed Genes). Follow these steps:</p> <ol> <li>First, we load the DEGs from Example 1, available on the DISCO website.</li> <li>Finally, we convert the retrieved data into a Pandas DataFrame, which will serve as the input for the <code>dt.CELLiD_enrichment</code> function. By running this function, we can obtain the desired enrichment analysis.</li> </ol>"}]}